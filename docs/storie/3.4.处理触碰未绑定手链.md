# Story 3.4: 处理触碰未绑定手链

## Status

Draft

## Story

**As a** 用户（无论是否已认证）,
**I want** 在触碰一个**未被绑定**的新手链时，被引导进入绑定流程,
**so that** 我可以将这个新手链与我的微信账号绑定.

## Acceptance Criteria

1.  当任何用户（包括已绑定过其他手链的用户 A）使用手机触碰一个**未被绑定**的 NFC 手链时，小程序能自动启动。
2.  后台检测到传入的 NFC ID 未被任何微信 OpenID 绑定 (`POST /api/v1/auth/login` 处理逻辑)。
3.  在此情况下，小程序应直接触发新用户绑定流程，展示“欢迎与绑定页” (`pages/bind/index`)，后续流程与 Story 1.1 的 AC 2-7 完全一致。

## Tasks / Subtasks

- [ ] **Task 1: (前端) 处理 NFC 启动与跳转绑定页 (AC: 1, 3)**
  - [ ] 复用或调整 `App.vue` (或全局入口) 的 NFC 启动逻辑。
  - [ ] 当小程序通过 NFC 启动并携带 `nfcId` 时，**前端在调用 `/auth/login` 之前或之后（根据后端设计决定），需要有一种机制判断此 `nfcId` 是否未绑定**。
    - **方案 A (前端判断，不推荐)**: 前端先调用一个独立的检查接口 `/bracelets/check/{nfcId}` (需新增)，如果返回未绑定，则直接跳转 `pages/bind/index`。
    - **方案 B (后端判断，推荐)**: 前端仍然调用 `/auth/login` 携带 `code` 和 `nfcId`。后端检测到 `nfcId` 未绑定时，执行绑定逻辑（如同 Story 1.1），并返回 `PROFILE_INCOMPLETE` 或 `AUTHENTICATED` 状态，前端根据此状态跳转。**（我们之前的 `/auth/login` 设计已涵盖此逻辑，后端会尝试绑定）**。
  - [ ] **确认采用方案 B**: 确保前端在 NFC 启动时，调用 `/auth/login` 后，能正确处理后端返回的 `PROFILE_INCOMPLETE` 或 `AUTHENTICATED` 状态，并相应跳转 (`pages/profile/index` 或 `pages/fortune/index`)，这实际上复用了 Story 1.1 和 Story 1.3 的部分前端逻辑。 **此故事前端主要在于确保 NFC 启动时调用了正确的登录/绑定接口**。
- [ ] **Task 2: (后端) 确认 `/auth/login` 接口处理未绑定 NFC ID (AC: 2, 3)**
  - [ ] 确认 Story 1.1 Task 4 中实现的 `/auth/login` 逻辑：当请求包含 `nfcId`，且通过 `nfcId` 在 `bracelets` 表中**未找到记录**或找到记录但 `user_id` 为 `null` 时：
    - 会继续使用 `code` 获取 `openid`，查找或创建 `user` 记录。
    - 会创建或更新 `bracelets` 记录，将 `nfcId` 与 `user_id` 关联。
    - 会根据用户信息完整度返回 `PROFILE_INCOMPLETE` 或 `AUTHENTICATED` 状态。
  - [ ] **无需为 `/auth/login` 添加额外逻辑**，现有设计已覆盖此场景。

## Dev Notes

- **前端**:
  - **核心逻辑**: 复用 `App.vue` 或全局入口的 NFC 启动逻辑，确保在获取到 `nfcId` 后调用 `/auth/login` 接口。
  - **流程复用**: 此场景下前端的行为实际上是复用了 Story 1.1（新用户首次绑定）或 Story 1.3（已认证用户绑定新手链）的登录和跳转逻辑。本故事主要确保 NFC -> `/auth/login` 这条路径对于未绑定手链是通畅的。
- **后端**:
  - **核心接口**: `/api/v1/auth/login` 的现有逻辑已能处理此场景。
  - **数据库**: 涉及 `users` 和 `bracelets` 表的查询、创建或更新。
- **编码标准**: 遵循 `docs/architecture/coding-standards.md`。

## Testing

- **前端单元测试 (Vitest)**:
  - 重点测试 `App.vue` 启动逻辑：在接收到 `nfcId` 参数时，是否会触发 `uni.login()` 和调用 `/auth/login` API。
- **后端单元测试 (Jest)**:
  - 重点测试 `AuthService` 处理 `/auth/login` 时：
    - 当传入的 `nfcId` 在数据库中**不存在**时，是否会继续获取 `openid`、创建/查找 `user`、创建 `bracelet` 记录并返回正确状态 (`PROFILE_INCOMPLETE` 或 `AUTHENTICATED`)。
    - 当传入的 `nfcId` 存在但 `user_id` 为 `null` 时，是否会更新 `bracelet` 记录关联 `userId` 并返回正确状态。
  - Mock Prisma Client 和 WeChat API 调用。
- **集成测试 (后端)**:
  - 测试 `/auth/login` 接口：
    - 使用一个用户的 `code` 和一个**从未绑定过**的 `nfcId` 调用，验证是否返回正确状态（`PROFILE_INCOMPLETE` 或 `AUTHENTICATED`），并在数据库中创建了 `bracelet` 记录并关联了用户。
- **手动/E2E 测试 (uts)**:
  - **核心流程**:
    - 使用一个**从未绑定过**的新手链，分别让**新用户**和**已绑定过其他手链的老用户**触碰手机。
    - 验证两者是否都能进入绑定流程（显示欢迎页 -> 点击授权 -> 跳转信息补全页或直接进入运势页），并且后台数据库中该手链已成功与对应用户关联。

## Change Log

| Date           | Version | Description | Author |
| :------------- | :------ | :---------- | :----- |
| 2025年10月24日 | 0.1     | 初始草稿    | SM     |
