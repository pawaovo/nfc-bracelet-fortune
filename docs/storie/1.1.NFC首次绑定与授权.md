# Story 1.1: NFC 首次绑定与授权

## Status

Draft

## Story

**As a** 首次使用的新用户,
**I want** 通过手机触碰新手链,
**so that** 可以拉起小程序并完成微信授权和手链绑定，开启我的专属运势体验.

## Acceptance Criteria

1.  当手机触碰一个**未绑定**的 NFC 手链时，能自动拉起本小程序。
2.  小程序启动后，展示“欢迎与绑定页” (`pages/bind/index`)。
3.  “欢迎与绑定页”包含指定的欢迎文案、手链示意图/图标、以及“微信授权并绑定”按钮。
4.  点击“微信授权并绑定”按钮后，正确触发微信授权流程 (`wx.login()`)。
5.  微信授权成功时，后台能成功获取用户微信 OpenID，并将其与当前手链的 NFC ID 建立唯一的绑定关系。
6.  绑定成功后，页面自动跳转至“个人信息补全页” (`pages/profile/index`)。
7.  若微信授权失败，应停留在“欢迎与绑定页”并给出用户友好的提示 (`uni.showToast`)。

## Tasks / Subtasks

- [ ] **Task 1: 创建欢迎与绑定页 (AC: 2, 3)**
  - [ ] 创建 `apps/wx-app/src/pages/bind/index.vue` 文件。
  - [ ] 实现页面布局，包含欢迎文案、手链图片占位符和绑定按钮，样式参考 UI/UX 规范。
  - [ ] 在 `apps/wx-app/src/pages.json` 中注册此页面。
- [ ] **Task 2: 实现 NFC 启动参数获取 (AC: 1)**
  - [ ] 在 `App.vue` 的 `onLaunch` 或页面的 `onLoad` 生命周期函数中，编写代码尝试获取小程序启动参数中的 `nfcId`。
  - [ ] 将获取到的 `nfcId` 存储在页面的 data 或 Pinia store 中，供后续 API 调用使用。
- [ ] **Task 3: 实现微信授权与后端绑定逻辑 (AC: 4, 5, 6, 7)**
  - [ ] 在 `pages/bind/index.vue` 中，为绑定按钮添加点击事件处理函数 `handleBindClick`。
  - [ ] 在 `handleBindClick` 中，调用 `uni.login()` 获取微信 `code`。
  - [ ] 调用封装好的 API 请求服务 (`apps/wx-app/src/api/auth.ts` - 需创建)，向后端 `/api/v1/auth/login` 发送 POST 请求，携带 `code` 和获取到的 `nfcId`。
  - [ ] 处理后端响应：
    - 如果 `status` 为 `PROFILE_INCOMPLETE`，将返回的 `token` 存储到 `uni.setStorageSync`，然后使用 `uni.redirectTo` 跳转到 `pages/profile/index`。
    - 如果后端返回错误或授权失败，使用 `uni.showToast` 显示错误提示。
- [ ] **Task 4: (后端) 实现 `/auth/login` 接口 NFC 绑定逻辑 (AC: 5)**
  - [ ] 在 `apps/api` 的 `AuthModule` 中，修改 `/auth/login` 接口的处理逻辑。
  - [ ] 当请求中包含 `nfcId` 时，在 `code2Session` 成功获取 `openid` 后：
    - 查询 `Bracelets` 表，检查 `nfcId` 是否已存在且 `user_id` 不为 null。如果已绑定，根据 PRD 规则（触碰他人手链）返回 `VISITOR_PREVIEW` 状态。
    - 如果 `nfcId` 不存在或 `user_id` 为 null，则查找或创建 `Users` 记录 (`openid`)。
    - 创建或更新 `Bracelets` 记录，将 `nfcId` 与 `user_id` 关联，记录 `bound_at` 时间。
    - 根据用户信息完整度（姓名、生日是否为空）返回 `PROFILE_INCOMPLETE` 或 `AUTHENTICATED` 状态及 `token`。

## Dev Notes

- **NFC 读取**: 前端需处理微信 NFC API (`wx.nfc.*` 或 uni-app 封装的 API) 的初始化和事件监听，以在合适的时机读取到 `nfcId`。具体的 NFC API 使用方法需查阅微信官方文档。启动参数传递 `nfcId` 是关键。
- **API 接口**: 前端需调用 `/api/v1/auth/login`，后端需实现该接口处理 `code` 和可选的 `nfcId`。
- **状态管理**: 用户登录成功后返回的 `token` 需要安全存储在前端 (`uni.setStorageSync`)，并在后续请求中携带。
- **页面跳转**: 绑定成功后使用 `uni.redirectTo` 跳转到信息补全页，避免用户可以返回绑定页。
- **后端逻辑**: 后端 `/auth/login` 接口需要处理多种情况：新用户绑定、已绑定用户登录、触碰他人手链等，并返回正确的 `status`。
- **数据库**: 后端需与 `users` 和 `bracelets` 表交互。
- **编码标准**: 遵循 `docs/architecture/coding-standards.md`。

## Testing

- **前端单元测试 (Vitest)**:
  - 测试欢迎页面的渲染是否符合预期。
  - Mock `uni.login`, `uni.request`, `uni.redirectTo`, `uni.showToast` 等 API。
  - 测试 `handleBindClick` 在不同 API 响应下的行为（成功跳转、失败提示）。
- **后端单元测试 (Jest)**:
  - 测试 `AuthService` 处理微信 `code` 和 `nfcId` 的逻辑。
  - Mock Prisma Client, WeChat API 调用。
  - 验证不同场景下（新用户、已绑定、触碰他人）返回正确的 `status` 和 `token`。
- **集成测试 (后端)**:
  - 测试 `/auth/login` 接口在携带 `nfcId` 时，与数据库交互（创建/查询 User, Bracelet）的正确性。
- **手动测试**:
  - 使用真实手机和 NFC 手链测试从未绑定到绑定成功的完整流程。
  - 测试微信授权失败的场景。
  - 测试网络请求失败的场景。

## Change Log

| Date           | Version | Description | Author |
| :------------- | :------ | :---------- | :----- |
| 2025年10月24日 | 0.1     | 初始草稿    | SM     |
